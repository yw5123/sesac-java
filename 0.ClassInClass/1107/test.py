gems = [3, 3, 1, 2, 3, 2, 2, 3, 3, 1]

# 1. 리스트 안에 1이 존재하는지 여부?
# 반복문을 이용해서 리스트를 순회하며
for gem in gems:
    # 1이라는 데이터가 발견되면
    if gem == 1:
        # 찾았음을 표시하고 종료
        print("1 존재")
        break

for idx in range(len(gems)):
    if gems[idx] == 1:
        print("1 존재")
        break

##################################################

# 2. 리스트에서 가장 큰 숫자를 찾기
lst = [56, 23, 43, 87, 12, 457, 86]

## 내장 함수 사용 금지
# print(max(lst))

# 코드를 작성하기 전에 한글로 적어보기 (꼭!)


# 내가 작성한 내용

# 최대값을 담을 변수 선언
# 리스트의 첫번째 값을 할당
maxNum = lst[0]

# 리스트를 순회하며
for num in lst:
    # 현재 값이 기존의 최대값보다 크면
    if num > maxNum:
        # 최대값을 현재 값으로 변경한다
        maxNum = num

# 마지막에 최대값 변수에 저장된 값이 최대값
print(maxNum)


# 강사님이 작성한 내용

# 초기값(가장 큰 숫자 후보)을 세팅
# 초기값 1 - 충분히, 아주아주 작은 값을 넣어줘야함
ans = -float("INF")  # float("INF") == 무한대

# 초기값 2 - 리스트의 첫번째 값
ans = lst[0]

# 반복문을 이용해 리스트를 선형 탐색
for num in lst:
    # 방금 뽑은 값이 후보보다 크다면?
    if num > ans:
        # 숫자를 갱신
        ans = num

print(ans)

##################################################

# 3. 집계 알고리즘
gems = [3, 3, 1, 2, 3, 2, 2, 3, 3, 1]

# 3-1. 딕셔너리를 이용한 집계 - dict() 라고 적어서 선언할 수도 있음
# 딕셔너리에 1:0, 2:0, 3:0이라는 키값을 만든다.
grades = {1: 0, 2: 0, 3: 0}

# 반복문을 이용해서 리스트 선형 탐색
for gem in gems:
    # 방금 뽑은 등급에 따라 딕셔너리 벨류값을 갱신
    grades[gem] += 1

print(grades)


# 3-2. 리스트를 이용한 집계 - 인덱스를 이용
# 빈 판 만들기
grades = [0, 0, 0, 0]
# grades = [0] * 4  # 이렇게도 작성 가능

for gem in gems:
    grades[gem] += 1

print(grades)
